{
	"Print to console": {
		// "scope": "javascript,typescript,php,java,css,html,react",
		"prefix": ["reactlifeCycle","reactshengmingzhouqihanshu"],
		"body": [
			"//会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 componentWillUnmount() 里取消订阅",
			"componentDidMount(){",
			"    $1",
			"}",
			"//会在更新后会被立即调用。首次渲染不会执行此方法。当组件更新后，可以在此处对 DOM 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。（例如，当 props 未发生变化时，则不会执行网络请求）。",
			"componentDidUpdate(){",
			"    $2",
			"}",
			"//会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等。componentWillUnmount() 中不应调用 setState()，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。",
			"componentWillUnmount(){",
			"    $3",
			"}",
			"//主要用于性能优化(部分更新)，一用于控制组件重新渲染的生命周期，由于在 react 中，setState 以后，state 发生变化，组件会进入重新渲染的流程，在这里 return false 可以阻止组件的更新，因为 react 父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要所有子组件都跟着重新渲染的，因此需要在子组件的该生命周期中做判断。",
			"shouldComponentUpdate(nextProps,nextState)",
			"//如果props传入的内容不需要影响到你的state，那么就需要返回一个null，这个返回值是必须的，所以尽量将其写到函数的末尾。",
			" getDerivedStateFromProps(nextProps, prevState)",
			"//getSnapshotBeforeUpdate 会在最终的 render 之前被调用，也就是说在 getSnapshotBeforeUpdate 中读取到的 DOM 元素状态是可以保证与 componentDidUpdate 中一致的。",
			" getSnapshotBeforeUpdate(prevProps, prevState)",
			"// 对错误进行处理",
			" componentDidCatch()",
			"//在挂载之前被调用。它在 render() 之前调用，因此在此方法中同步调用 setState() 不会触发额外渲染。通常，我们建议使用 constructor() 来初始化 state。",
			"UNSAFE_componentWillMount(){",
			"",
			"}",
			"//会在已挂载的组件接收新的 props 之前被调用。如果你需要更新状态以响应 prop 更改（例如，重置它），你可以比较 this.props 和 nextProps 并在此方法中使用 this.setState() 执行 state 转换。",
			"UNSAFE_componentWillReceiveProps(){",
			"",
			"}",
			"//当组件收到新的 props 或 state 时，会在渲染之前调用 UNSAFE_componentWillUpdate()。使用此作为在更新发生之前执行准备更新的机会。初始渲染不会调用此方法。",
			"UNSAFE_componentWillUpdate(){",
			"",
			"}",
		],
		"description": "react生命周期"
	}
}